/**********************************************************
 * This file is generated by 20-sim ANSI-C Code Generator
 *
 *  file:  %FILE_NAME%
 *  model: %MODEL_NAME%
 *  expmt: %EXPERIMENT_NAME%
 *  date:  %GENERATION_DATE%
 *  time:  %GENERATION_TIME%
 *  user:  %USER_NAME%
 *  from:  %COMPANY_NAME%
 *  build: %GENERATION_BUILD%
 **********************************************************/

/* This file contains the implementation of the FMI functions
   Please check the fmiSunctions.h file for more details
*/

/* The FMI related headers */
#include "fmiFunctions.h"
#include "fmiGUID.h"

/* Our own include files */
#include "xxsubmod.h"

/* The system include files */
#include <string.h>

/* our own component identifier 
   this can become a pointer to a full structure that is filled when instantiating
   for now a simple non-NULL string pointer is returned
*/
#define xxComponent "%SUBMODEL_NAME%"

/* Inquire version numbers of header files */
DllExport const char* fmiGetTypesPlatform()
{
    return fmiPlatform;
}
DllExport const char* fmiGetVersion()
{
    return fmiVersion;
}
DllExport fmiStatus fmiSetDebugLogging  (fmiComponent c, fmiBoolean loggingOn)
{
    return fmiOK;       /* not yet */
}

/* Data Exchange Functions*/
DllExport fmiStatus fmiGetReal   (fmiComponent c, const fmiValueReference vr[], size_t nvr, fmiReal    value[])
{
    unsigned int i;
    for (i = 0; i < nvr; i++)
    {
        value [i] = %VARPREFIX%MEMORY[ vr[i] ];
    }
    return fmiOK;
}
DllExport fmiStatus fmiGetInteger(fmiComponent c, const fmiValueReference vr[], size_t nvr, fmiInteger value[])
{
    return fmiError;    /* not yet */
}
DllExport fmiStatus fmiGetBoolean(fmiComponent c, const fmiValueReference vr[], size_t nvr, fmiBoolean value[])
{
    return fmiError;    /* not yet */
}
DllExport fmiStatus fmiGetString (fmiComponent c, const fmiValueReference vr[], size_t nvr, fmiString  value[])
{
    return fmiError;    /* not yet */
}

DllExport fmiStatus fmiSetReal    (fmiComponent c, const fmiValueReference vr[], size_t nvr, const fmiReal    value[])
{
    unsigned int i;
    for (i = 0; i < nvr; i++)
    {
        %VARPREFIX%MEMORY[ vr[i] ] = value [i];
    }
    return fmiOK;
}
DllExport fmiStatus fmiSetInteger (fmiComponent c, const fmiValueReference vr[], size_t nvr, const fmiInteger value[])
{
    return fmiError;    /* not yet */
}
DllExport fmiStatus fmiSetBoolean (fmiComponent c, const fmiValueReference vr[], size_t nvr, const fmiBoolean value[])
{
    return fmiError;    /* not yet */
}
DllExport fmiStatus fmiSetString  (fmiComponent c, const fmiValueReference vr[], size_t nvr, const fmiString  value[])
{
    return fmiError;   /* not yet */
}

/* FMI functions for Co-Simulation 1.0 */
fmiComponent fmiInstantiateSlave(fmiString  instanceName, fmiString GUID,
    fmiString fmuLocation, fmiString mimeType, fmiReal timeout, fmiBoolean visible,
    fmiBoolean interactive, fmiCallbackFunctions functions, fmiBoolean loggingOn) 
{
    if (!functions.logger) 
        return NULL; // we cannot even log this problem
    if (!instanceName || strlen(instanceName)==0) { 
        functions.logger(NULL, "?", fmiError, "error",
                "Missing instance name.");
        return NULL;
    }

	/* Check whether the given GUID equals our GUID */
	if( strncmp(GUID, FMI_GUID, strlen(GUID)) != 0 )
	{
		functions.logger(NULL, instanceName, fmiError, "error",
			"Wrong GUID %s. Expected %s.", GUID, FMI_GUID);
		return NULL;
	}

    /* only one static instance for now */
    return (fmiComponent) xxComponent;
}

fmiStatus fmiInitializeSlave(fmiComponent c, fmiReal tStart, fmiBoolean StopTimeDefined, fmiReal tStop) 
{
    /* copy the arguments */
    %VARPREFIX%start_time = tStart;
    if (StopTimeDefined == fmiTrue) 
    {
        %VARPREFIX%finish_time = tStop;
    }

    /* initialize the submodel itself */
    %FUNCTIONPREFIX%InitializeSubmodel (tStart);

    /* all done */
    return fmiOK;
}

fmiStatus fmiTerminateSlave(fmiComponent c) 
{
	/* Perform the final calculations */
	%FUNCTIONPREFIX%TerminateSubmodel (%VARPREFIX%%XX_TIME%);

    /* all done */
    return fmiOK;
}

fmiStatus fmiResetSlave(fmiComponent c) 
{
    /* initialize the submodel itself */
    %FUNCTIONPREFIX%InitializeSubmodel (%VARPREFIX%start_time);

    /* all done */
    return fmiOK;
}

void fmiFreeSlaveInstance(fmiComponent c) 
{
    /* only one static instance (done automatically) */
}

fmiStatus fmiSetRealInputDerivatives(fmiComponent c, const fmiValueReference vr[], size_t nvr,
    const fmiInteger order[], const fmiReal value[]) 
{
    /* not yet */
    return fmiError;
}

fmiStatus fmiGetRealOutputDerivatives(fmiComponent c, const fmiValueReference vr[], size_t nvr,
    const fmiInteger order[], fmiReal value[]) 
{
    /* not yet */
    return fmiError;
}

fmiStatus fmiCancelStep(fmiComponent c) 
{
    /* not yet */
    return fmiError;
}

fmiStatus fmiDoStep(fmiComponent c, fmiReal currentCommunicationPoint,
    fmiReal communicationStepSize, fmiBoolean newStep) 
{
    /* Treat also case of zero step, i.e. during an event iteration */
    if (communicationStepSize == 0) 
    {
        return fmiOK;
    }

    /* as long as we are not passed our communication point */
    while (%VARPREFIX%%XX_TIME% < (currentCommunicationPoint + communicationStepSize))
    {
        /* check for termination first */
        if ((%VARPREFIX%%XX_TIME% > %VARPREFIX%finish_time) || (%VARPREFIX%stop_simulation == XXTRUE))
        {
            /* we're done */
            return fmiError;
        }
        
		/* Call the submodel to calculate the output, and increase the time as well */
		%FUNCTIONPREFIX%CalculateSubmodel (%VARPREFIX%%XX_TIME%);
    }
    
    /* for now */
    return fmiOK;
}

fmiStatus fmiGetStatus(fmiComponent c, const fmiStatusKind s, fmiStatus* value) 
{
    /* all fine? */
    return fmiOK;
}

fmiStatus fmiGetRealStatus(fmiComponent c, const fmiStatusKind s, fmiReal* value)
{
    /* all fine? */
    return fmiOK;
}

fmiStatus fmiGetIntegerStatus(fmiComponent c, const fmiStatusKind s, fmiInteger* value)
{
    /* not yet */
    return fmiDiscard;
}

fmiStatus fmiGetBooleanStatus(fmiComponent c, const fmiStatusKind s, fmiBoolean* value)
{
    /* not yet */
    return fmiDiscard;
}

fmiStatus fmiGetStringStatus(fmiComponent c, const fmiStatusKind s, fmiString*  value)
{
    /* not yet */
    return fmiDiscard;
}