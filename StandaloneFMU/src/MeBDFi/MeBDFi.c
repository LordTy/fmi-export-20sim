/**********************************************************
 * This file is generated by the 20-sim C++ Code Generator
 *
 *  file:  %FILE_NAME%
 *  subm:  %SUBMODEL_NAME%
 *  model: %MODEL_NAME%
 *  expmt: %EXPERIMENT_NAME%
 *  date:  %GENERATION_DATE%
 *  time:  %GENERATION_TIME%
 *  user:  %USER_NAME%
 *  from:  %COMPANY_NAME%
 *  build: %GENERATION_BUILD%
 **********************************************************/

#include <float.h>
#include <string.h>
#include <math.h>
#include <stdio.h>

#include "MeBDFi.h"

/* this variable is needed for the callback functions */
static Simulator *global_simulator = NULL;
static MeBDFiMethod *global_int_method = NULL;

/* immediate recall for continuation after m_idid < 0 posible?
 *	-1:  no;	0, 1:  yes, with m_info[0] = 0, 1 respectively
 */
static int ididrestart[] = {  -1, /* 0 = INTEGRATION WAS COMPLETED TO TOUT OR BEYOND, will not happen */
							  -1, /* -1 = THE INTEGRATION WAS HALTED AFTER FAILING TO PASS THE
								   *   ERROR TEST EVEN AFTER REDUCING H BY A FACTOR OF
								   *   1.E10 FROM ITS INITIAL VALUE.
								   */
							  -1, /* -2 = AFTER SOME INITIAL SUCCESS, THE INTEGRATION WAS
								   *  HALTED EITHER BY REPEATED ERROR TEST FAILURES OR BY
								   *   A TEST ON RTOL/ATOL.  TOO MUCH ACCURACY HAS BEEN REQUESTED
								   */
							  -1, /* -3 = THE INTEGRATION WAS HALTED AFTER FAILING TO ACHIEVE
								   *   CORRECTOR CONVERGENCE EVEN AFTER REDUCING H BY A
								   *  FACTOR OF 1.E10 FROM ITS INITIAL VALUE
								   */
							  -1, /* -4 = IMMEDIATE HALT BECAUSE OF ILLEGAL VALUES OF INPUT
								   *   PARAMETERS. SEE PRINTED MESSAGE.
								   */
							   0, /* -5 = IDID WAS -1 ON INPUT, BUT THE DESIRED CHANGES OF
								   *  PARAMETERS WERE NOT IMPLEMENTED BECAUSE TOUT
								   *  WAS NOT BEYOND T.  INTERPOLATION AT T = TOUT WAS
								   *  PERFORMED AS ON A NORMAL RETURN.  TO TRY AGAIN,
								   *   SIMPLY CALL AGAIN WITH IDID = -1 AND A NEW TOUT.
								   */
							  -1,  /* -6 = MAXIMUM ALLOWABLE NUMBER OF INTEGRATION STEPS EXCEEDED.
								    *   TO CONTINUE THE USER SHOULD RESET IWORK(14)
									*/
							  -1, /* -7 = STEPSIZE IS TOO SMALL (LESS THAN SQRT(UROUND)/100) */
							  -1, /* -8 */
							  -1, /* -9 */
							  -1, /* -10 */
							  -1, /* -11 = INSUFFICIENT REAL WORKSPACE FOR THE INTEGRATION */
							  -1};/* -12 = INSUFFICIENT INTEGER WORKSPACE FOR THE INTEGRATION */

/* call to actual integration algorithm, see ddassl.c */
#include "include/f2c.h"

int _cdecl mebdfi_(int *n, double *t0, double *ho,
				double *y0, double *yprime, double *tout, double *
				tend, int *mf, int *idid, int *lout, int *lwork,
				double *work, int *liwork, int *iwork, int *mbnd,
				int *maxder, int *itol, double *rtol, double *atol,
				double *rpar, int *ipar,
				U_fp pderv,
				int (_cdecl *fcn) (	int *, double *, double *, double *,
									double *, int *, double *, double *),
				int * ierr);
/*     PDERV(T,Y,PD,N,YPRIME,MBND(4),CON,IPAR,RPAR,IERR) */
/*     RESID(N,T,Y,DELTA,YPRIME,IPAR,RPAR,IERR) */


/************************************************************************/
/*                                                                      */
/************************************************************************/
/*
	34 integers
	25 doublereal
	4 logicals
*/
/************************************************************************/
/*                                                                      */
/************************************************************************/
void RememberMeBDFiStatics(int *mebdfStaticInts,
							double *mebdfStaticDoubles,
							long int*mebdfStaticLogicals);
void SetMeBDFiStatics(int *mebdfStaticInts,
						double *mebdfStaticDoubles,
						long int*mebdfStaticLogicals);


/* method to solve the initial values for the algebraic loop variables */
int _cdecl hybrd1_( int (_cdecl *fcn) (int*, double*, double*, int*),
				int *n,
				double *x, double *fvec, double *tol,
				int *info,
				double *wa,
				int *lwa
		);



int _cdecl MeBDFCalcAlgloopRes(XXModelInstance* %VARPREFIX%model_instance, int * /*n*/, double *xx, double *delta, int * /*flag*/)
{
	int i;

	if( global_simulator == NULL )
		return 1;

	double *algloop_in = %VARPREFIX%model_instance->%XX_ALG_IN_ARRAY_NAME%;  /*global_simulator->GetAlgLoopIn(); */
	double *algloop_out = %VARPREFIX%model_instance->%XX_ALG_OUT_ARRAY_NAME%;  /*global_simulator->GetAlgLoopOut(); */

	double *constraint_in = &%VARPREFIX%model_instance->%XX_ALG_IN_ARRAY_NAME%[%NUMBER_ALGLOOPS%];  /*global_simulator->GetConstraintIn();*/
	double *constraint_out = &%VARPREFIX%model_instance->%XX_ALG_OUT_ARRAY_NAME%[%NUMBER_ALGLOOPS%];  /*global_simulator->GetConstraintOut(); */

	int nr_algloops = %NUMBER_ALGLOOPS% /*global_simulator->GetNrAlgLoop(); */
	int nr_constraints = %NUMBER_CONSTRAINTS% /*global_simulator->GetNrConstraints(); */

	if( nr_algloops > 0)
		memcpy(algloop_in, xx, nr_algloops * sizeof(double));
	if( nr_constraints > 0 )
	{
		int index = 0;
		for( i = 0; i < nr_constraints; i++ )
		{
			if( %VARPREFIX%model_instance->m_mebdfi_method->m_active_contraint_array[i] )
			{
				constraint_in[i] = xx[nr_algloops + index];
				index++;
			}
			else
			{
				// is this necessary?
				constraint_in[i] = 0.0;
			}
		}
	}

	/* evaluate the dynamic part to calculate the new rates/depstates/algouts/constraintouts */
	%FUNCTIONPREFIX%CalculateDynamic (%VARPREFIX%model_instance);

	for (i = 0; i < nr_algloops; i++)
	{
		delta[i] = algloop_out[i] - algloop_in[i];
	}

	int index = 0;
	for( i = 0; i < nr_constraints; i++ )
	{
		if( %VARPREFIX%model_instance->m_mebdfi_method->m_active_contraint_array[i] )
		{
			delta[index + nr_algloops] = constraint_out[i];
			index++;
		}
	}
	return 0;
}

/************************* ImplicitResidu() *************************
 * Call-back procedure for DASSL.
 * Assumed is that  y == states  and  yprime == rates , so these arguments
 * are ignored and not copied to the machine value arrays!!!
 * Compute the residu of an implicit model,
 * used for implicit integration methods.
 * Precondition: for sstime the excitation equations are calculated.
 * Due to change in ddassl.f, rpar[0] = alpha0/h.
 */
int _cdecl MeBDFImplicitResidu(XXModelInstance* %VARPREFIX%model_instance, int *n, double *time, double *y, double *delta,
						  double *yprime, int *ipar, double *rpar, double *ierr)
{
	int i;

	/* temporary variable substitution */
	double *rates_est;
	double *states_est;

	/* do time-dept. calculations once per time step */
	%VARPREFIX%model_instance->time = *time;

	int nr_ind_states = %NUMBER_STATES%;
	int nr_dep_states = %NUMBER_DEPSTATES%;
	int nr_alg_loop = %NUMBER_ALGLOOPS%;
	int nr_constraints = %NUMBER_CONSTRAINTS%;

	double *indep_states = %VARPREFIX%model_instance->%XX_STATE_ARRAY_NAME; /*global_simulator->GetIndepStates(); */
	double *dep_rates = %VARPREFIX%model_instance->%XX_DEP_STATE_ARRAY_NAME%; /*global_simulator->GetDepRates(); */
	double *algloop_in = %VARPREFIX%model_instance->%XX_ALG_IN_ARRAY_NAME%;  /*global_simulator->GetAlgLoopIn(); */
	double *constraint_in = &%VARPREFIX%model_instance->%XX_ALG_IN_ARRAY_NAME%[%NUMBER_ALGLOOPS%];  /*global_simulator->GetConstraintIn(); */

	/* sometimes the MeBDF method has other arrays given then given
	 * by us in the call to MeBDF. So check this, and make a copy if necessary
	 * the BDF method always uses the given arrays.
	 */
	if( indep_states != y )
	{
		if( nr_ind_states > 0 )
			memcpy(indep_states, y, nr_ind_states * sizeof(double));
		if( nr_alg_loop > 0 )
			memcpy(algloop_in, &y[nr_ind_states + nr_dep_states], nr_alg_loop * sizeof(double));
		if( nr_constraints > 0 )
		{
				int index = 0;
				for( i = 0; i < nr_constraints; i++)
				{
					if( %VARPREFIX%model_instance->m_mebdfi_method->m_active_contraint_array[i] )
					{
						constraint_in[i] = y[nr_ind_states + nr_dep_states + nr_alg_loop + index];
						index++;
					}
					else
					{
						/* ??????????????????????????????????? */
						constraint_in[i] = 0.0;
					}
				}
			}
		}
	}
	if( nr_dep_states > 0 )
	{
		// only copy if the source is different as the destination
		if( dep_rates != &yprime[nr_ind_states] )
			memcpy(dep_rates, &yprime[nr_ind_states], nr_dep_states * sizeof(double));
	}

	/* evaluate the dynamic part to calculate the new rates/depstates/algouts/constraintouts */
	%FUNCTIONPREFIX%CalculateDynamic (%VARPREFIX%model_instance);


	/* calculate corresponding residus; 'est' is input from impl. method;
	 * the derivatives of the alg.loop var.s are not used (yprime + noffs_alg)
	 */

	/* calculate the error in the rates (should go to zero for a good step) */
	rates_est = yprime;

	double *indep_rates = %VARPREFIX%model_instance->%XX_RATE_ARRAY_NAME; /* global_simulator->GetIndepRates();*/
	double *dep_states = %VARPREFIX%model_instance->%XX_DEP_RATE_ARRAY_NAME%; /*global_simulator->GetDepStates();*/
	double *algloop_out = %VARPREFIX%model_instance->%XX_ALG_OUT_ARRAY_NAME%;  /*global_simulator->GetAlgLoopOut();*/
	double *constraint_out = &%VARPREFIX%model_instance->%XX_ALG_OUT_ARRAY_NAME%[%NUMBER_ALGLOOPS%];  /*global_simulator->GetConstraintOut(); */

	for (i = 0; i < nr_ind_states; i++, delta++)
	{
		*delta = indep_rates[i] - rates_est[i];
	}

	// and calculate the error in the STATES
	states_est = y + nr_ind_states;
	for (i = 0; i < nr_dep_states; i++, delta++)
	{
		*delta = dep_states[i] - states_est[i];
	}

	// and calculate the error in the STATES (which here is the algebraic loop in
	// variables).
	states_est = y + nr_ind_states + nr_dep_states;
	for( i = 0; i < nr_alg_loop; i++, delta++)
	{
		*delta = algloop_out[i] - states_est[i];
	}

	if( global_int_method )
	{
		int index = 0;
		for( i = 0; i < nr_constraints; i++)
		{
			if( global_int_method->m_active_contraint_array[i] )
			{
				// the constraint should go to zero.
				delta[index] = constraint_out[i];
				index++;
			}
		}
	}
	else
	{
		for( i = 0; i < nr_constraints; i++, delta++)
			// the constraint should go to zero.
			*delta = constraint_out[i];
	}

	return 0;
}
static XXBoolean MeBDFStaticsInitialized = XXFALSE;
void IntegrationMethod_Constructor(IntegrationMethod *intMethod, XXModelInstance* model_instance)
{
	intMethod->m_take_desired_step_busy = XXFALSE;
	m_model_instance = model_instance;
}
void ImplicitMethod_Constructor(ImplicitMethod *implMethod, XXModelInstance* model_instance)
{
	/* do the construction of the Implicit Method */
	IntegrationMethod_Constructor(&implMethod->m_integration_method, model_instance);

	/* default values for the tolerances.*/
	implMethod->m_absolute_tolerance = 1.0e-5;
	implMethod->m_relative_tolerance = 1.0e-5;

	implMethod->m_alg_absolute_tolerance = 1.0e-5;
	implMethod->m_alg_relative_tolerance = 1.0e-5;
}
void ImplicitVariablesStep_Constructor(ImplicitMethod *implVarStepMethod, XXModelInstance* model_instance)
{
	/* do the construction of the Implicit Method */
	ImplicitMethod_Constructor(&implVarStepMethod->m_implicit_method, model_instance);
	
	/* default step sizes */
	implVarStepMethod->m_use_initial_step_size = XXFALSE;
	implVarStepMethod->m_use_maximum_step_size = XXFALSE;

	implVarStepMethod->m_initial_step_size = 0.001;
	implVarStepMethod->m_maximum_step_size = 1.0;

	implVarStepMethod->m_last_step_size = 0.0;
}
void MeBDFiMethod_Constructor (MeBDFiMethod *meBDFi, XXModelInstance* model_instance)
{
	/* do the construction of the implicit variables step part */
	ImplicitVariablesStep_Constructor(&meBDFi->m_implicit_variables_step, model_instance);
	
	meBDFi->m_use_fixed_step_size = XXFALSE;
	meBDFi->m_fixed_step_size = 0.0;
	meBDFi->m_use_comm_int = XXFALSE;
	meBDFi->m_comm_int = 1.0;

	meBDFi->m_tout = 0.0;
	meBDFi->m_local_initialStepSize = 0.0;
	meBDFi->m_method_flag = 22;
	meBDFi->m_idid = 1; /* for the first call */
	meBDFi->m_lout = 0;	/* output channel */
	meBDFi->m_mbnd = NULL;
	meBDFi->m_maxder = 7;
	meBDFi->m_itol = 2;
	meBDFi->m_rtol = NULL;
	meBDFi->m_atol = NULL;
	meBDFi->m_rpar = 0.0;
	meBDFi->m_ipar = 0;
	meBDFi->m_ierr = 0;
	meBDFi->m_lwork = 0;
	meBDFi->m_work = NULL;
	meBDFi->m_liwork = 0;
	meBDFi->m_iwork = NULL;

	meBDFi->m_prev_work = NULL;
	meBDFi->m_prev_iwork = NULL;
	meBDFi->m_prev_idid = 0;

	meBDFi->m_work_states = NULL;
	meBDFi->m_work_rates = NULL;

	meBDFi->m_check_constraints = XXTRUE;
	meBDFi->m_active_contraint_array = NULL;
	meBDFi->m_nr_active_constraints = 0;

	meBDFi->m_times_step_continued = 0;

	// and new work arrays to make the bdf method re-entrant */
	memset(meBDFi->m_mebdfStaticInts, 0, 35 * sizeof(int));
	memset(meBDFi->m_mebdfStaticDoubles, 0, 26 * sizeof(double)); 
	memset(meBDFi->m_mebdfStaticLogicals, 0, 5 * sizeof(long int));
}
void IntegrationMethod_Destructor(IntegrationMethod *intMethod)
{
	/* nothing to destruct */
}
void ImplicitMethod_Destructor(ImplicitMethod *implMethod)
{
	/* do the destruction of the Implicit Method */
	IntegrationMethod_Destructor(&implMethod->m_integration_method);

	/* nothing to destruct */
}
void ImplicitVariablesStep_Destructor(ImplicitVariablesStep *implVarStepMethod)
{
	/* do the destruction of the Implicit Method */
	ImplicitMethod_Destructor(&implVarStepMethod->m_implicit_method);

	/* nothing to destruct */
}
void MeBDFiMethod_Desctructor(MeBDFiMethod *mebdfi_method)
{
	ImplicitVariablesStep_Destructor(&meBDFi->m_implicit_variables_step);

	if( mebdfi_method->m_mbnd )
	{
		free(mebdfi_method->m_mbnd);
		mebdfi_method->m_mbnd = NULL;
	}
	if( mebdfi_method->m_work )
	{
		free(mebdfi_method->m_work);
		mebdfi_method->m_work = NULL;
	}
	if( mebdfi_method->m_iwork )
	{
		free(mebdfi_method->m_iwork);
		mebdfi_method->m_iwork = NULL;
	}
	if( mebdfi_method->m_work_states )
	{
		free(mebdfi_method->m_work_states);
		mebdfi_method->m_work_states = NULL;
	}
	if( mebdfi_method->m_work_rates )
	{
		free(mebdfi_method->m_work_rates);
		mebdfi_method->m_work_rates = NULL;
	}
	if( mebdfi_method->m_prev_work )
	{
		free(mebdfi_method->m_prev_work);
		mebdfi_method->m_prev_work = NULL;
	}
	if( mebdfi_method->m_prev_iwork )
	{
		free(mebdfi_method->m_prev_iwork);
		mebdfi_method->m_prev_iwork = NULL;
	}

	/* check for previous attributes */
	if( mebdfi_method->m_rtol )
	{
		free(mebdfi_method->m_rtol);
		mebdfi_method->m_rtol = NULL;
	}
	if( mebdfi_method->m_atol )
	{
		free(mebdfi_method->m_atol);
		mebdfi_method->m_atol = NULL;
	}
	if( mebdfi_method->m_active_contraint_array )
	{
		free(mebdfi_method->m_active_contraint_array);
		mebdfi_method->m_active_contraint_array = NULL;
	}
}

void MeBDFiMethod::DetermineActiveConstraints(MeBDFiMethod *mebdfi_method)
{
	int nr_constraints = %NUMBER_CONSTRAINTS%;

	if( nr_constraints == 0 || mebdfi_method->m_check_constraints == XXFALSE )
	{
		mebdfi_method->m_nr_active_constraints = nr_constraints;
		return;
	}

	int nr_ind_states = %NUMBER_STATES%;
	int nr_dep_states =  %NUMBER_DEPSTATES%;
	int nr_alg_loop = %NUMBER_ALGLOOPS%;

	// the possible inputs
	double *indep_states = m_simulator->GetIndepStates();
	double *dep_states = m_simulator->GetDepStates();
	double *indep_rates = m_simulator->GetIndepRates();
	double *dep_rates = m_simulator->GetDepRates();
	double *algloop_in = m_simulator->GetAlgLoopIn();
	double *algloop_out = m_simulator->GetAlgLoopOut();
	double *constraint_in = m_simulator->GetConstraintIn();

	// and the output to check
	double *constraint_out = m_simulator->GetConstraintOut();

	// make a Jacobian to see if a constraint can be handled
	int i, j;
	double relEps = m_relative_tolerance;//1e-3;
	double absEps = m_absolute_tolerance;//1e-5;

	double eps = 0.001 * m_absolute_tolerance; // 1e-8;

	// make sure we don't a major integration step
	m_simulator->m_major_step = XXFALSE;

	m_simulator->CalcStatic();

	// and calculate the initial value problem
	m_simulator->CalcInput();

	// and once the dynamic block
	// so we can store the current result.
	m_simulator->CalcDynamic();

	double *nowVal = new double[nr_constraints + 1];

	m_nr_active_constraints = 0;
	for( i = 0; i < nr_constraints; i++)
		m_active_contraint_array[i] = XXFALSE;

	// remember the current values.
	memcpy(nowVal, constraint_out, nr_constraints * sizeof(double));

	//********************************************************************
	//
	// INDEP STATES
	//
	//********************************************************************
	for( i = 0; i < nr_ind_states; i++)
	{
		// if every constraint is controllable then bail out early
		if( m_nr_active_constraints == nr_constraints )
			break;

		double nowStateVal = indep_states[i];
		if( fabs(nowStateVal) > m_absolute_tolerance )
			indep_states[i] += nowStateVal *relEps;
		else
			indep_states[i] += absEps;

		// do a model calculation with this small perturbation
		m_simulator->CalcDynamic();

		// and check if a constraint has changed
		for( j = 0; j < nr_constraints; j++)
		{
			// probably we should check this agains a small margin
			// because of numerical small errors
			// only calculate if necessary
			if( m_active_contraint_array[j] )
				continue;

			if( constraint_out[j] - nowVal[j] != 0.0 )
			{
				double relTo = 1.0;

				if( nowVal[j] != 0.0 )
				{
					if( constraint_out[j] != 0.0 )
						relTo = constraint_out[j];
					else
						relTo = nowVal[j];
				}

				if( fabs( (constraint_out[j] - nowVal[j]) / relTo) > eps )
				{
					m_nr_active_constraints++;

					m_active_contraint_array[j] = XXTRUE;
				}
			}
		}

		// and put back some values
		memcpy(constraint_out, nowVal, nr_constraints * sizeof(double));
		indep_states[i] = nowStateVal;

	}

	//********************************************************************
	//
	// Dep RATES
	//
	//********************************************************************
	for( i = 0; i < nr_dep_states; i++)
	{
		// if every constraint is controllable then bail out early
		if( m_nr_active_constraints == nr_constraints )
			break;

		double nowRateVal = dep_rates[i];
		if( nowRateVal > m_absolute_tolerance )
			dep_rates[i] += nowRateVal *relEps;
		else
			dep_rates[i] += absEps;

		// do a model calculation with this small perturbation
		m_simulator->CalcDynamic();

		// and check if a constraint has changed
		for( j = 0; j < nr_constraints; j++)
		{
			// only check if necessary
			if(  m_active_contraint_array[j] )
				continue;

			// probably we should check this agains a small margin
			// because of numerical small errors
			if( fabs( constraint_out[j] - nowVal[j]) > eps )
			{
				m_nr_active_constraints++;

				m_active_contraint_array[j] = XXTRUE;
			}
		}
		// and put back some values
		memcpy(constraint_out, nowVal, nr_constraints * sizeof(double));
		dep_rates[i] = nowRateVal;

	}

	//********************************************************************
	//
	// Alg Ins
	//
	//********************************************************************
	for( i = 0; i < nr_alg_loop; i++)
	{
		// if every constraint is controllable then bail out early
		if( m_nr_active_constraints == nr_constraints )
			break;

		double nowAlgLoopVal = algloop_in[i];
		if( fabs(nowAlgLoopVal) > m_absolute_tolerance )
			algloop_in[i] += nowAlgLoopVal *relEps;
		else
			algloop_in[i] += absEps;

		// do a model calculation with this small perturbation
		m_simulator->CalcDynamic();

		// and check if a constraint has changed
		for( j = 0; j < nr_constraints; j++)
			// only check if necessary
			if(  m_active_contraint_array[j] )
				continue;

			// probably we should check this agains a small margin
			// because of numerical small errors
			if( fabs( constraint_out[j] - nowVal[j]) > eps )
			{
				m_nr_active_constraints++;

				m_active_contraint_array[j] = XXTRUE;
			}
		}
		// and put back some values
		memcpy(constraint_out, nowVal, nr_constraints * sizeof(double));
		algloop_in[i] = nowAlgLoopVal;

	}

	//********************************************************************
	//
	// Constraints
	//
	//********************************************************************
	for( i = 0; i < nr_constraints; i++)
	{
		// if every constraint is controllable then bail out early
		if( m_nr_active_constraints == nr_constraints )
			break;

		double nowConstraintVal = constraint_in[i];
		if( fabs(nowConstraintVal) > m_absolute_tolerance )
			constraint_in[i] += nowConstraintVal *relEps;
		else
			constraint_in[i] += absEps;

		// do a model calculation with this small perturbation
		m_simulator->CalcDynamic();

		// and check if a constraint has changed
		for( j = 0; j < nr_constraints; j++)
		{
			// probably we should check this agains a small margin
			// because of numerical small errors
			if( fabs( constraint_out[j] - nowVal[j]) > eps )
			{
				m_nr_active_constraints++;

				m_active_contraint_array[j] = XXTRUE;
			}
		}
		// and put back some values
		memcpy(constraint_out, nowVal, nr_constraints * sizeof(double));
		constraint_in[i] = nowConstraintVal;
	}

	delete[] nowVal;
}

XXBoolean MeBDFiMethod::CheckNonActiveConstraints()
{
	int i;
	int nr_constraints = m_simulator->GetNrConstraints();

	// and the output to check
	double *constraint_out = m_simulator->GetConstraintOut();

	// check whether the non-active constraints
	// are still zero (implicitly determined)
	for( i = 0; i < nr_constraints; i++)
	{
		// probably we should check this agains a small margin
		// because of numerical small errors
		if( m_active_contraint_array[i] == XXFALSE )
		{
			// if too large, then return XXFALSE
			if( fabs(constraint_out[i]) > m_absolute_tolerance) //-6 )
				return XXFALSE;
		}
	}

	return XXTRUE;
}
// try to calculate the initial values of the algebraic loop variables.
XXBoolean MeBDFiMethod::DetermineAlgloop()
{
	int lwa, ifail;
	double *wa, *fvec, *x, xtol = m_alg_absolute_tolerance;

	int nr_ind_states = m_simulator->GetNrIndStates();
	int nr_dep_states =  m_simulator->GetNrDepStates();
	int nr_alg_loop = m_simulator->GetNrAlgLoop();
	int nr_constraints = m_simulator->GetNrConstraints();

	double *indep_states = m_simulator->GetIndepStates();
	double *dep_states = m_simulator->GetDepStates();
	double *indep_rates = m_simulator->GetIndepRates();
	double *dep_rates = m_simulator->GetDepRates();
	double *algloop_in = m_simulator->GetAlgLoopIn();
	double *algloop_out = m_simulator->GetAlgLoopOut();
	double *constraint_in = m_simulator->GetConstraintIn();

	// and the output to check
	double *constraint_out = m_simulator->GetConstraintOut();

	// only at the start of a simulation
	if( m_simulator->m_initState )
		DetermineActiveConstraints();

	int n;
	n = m_simulator->GetNrAlgLoop() + m_nr_active_constraints;
	if (n == 0)
		return XXTRUE;

    lwa = n * (3 * n + 16) / 2;
	wa = new double[lwa];
	fvec = new double[n + 1];
	x = new double[n + 1];
	// check if allocating went alright.
	if (x == NULL || wa == NULL || fvec == NULL)
	{
		// ShowErrorMessage(_T("Memory allocation error in Modified BDF method"));
		if( x )
			delete[] x;
		if( wa )
			delete[] wa;
		if( fvec )
			delete[] fvec;
		return XXFALSE;
    }
	memset(wa, 0, lwa * sizeof(double));
	memset(fvec, 0, (n + 1) * sizeof(double));

	// set the initial values of the algloop in to the x value
	// assume the algloop in already has these values
	if( nr_alg_loop > 0 )
		memcpy(x, algloop_in, nr_alg_loop * sizeof(double));

	// set the initial values of the constraint in to the x value
	// assume the constraint in already has these values
	if( nr_constraints > 0 )
	{
		if( m_nr_active_constraints == nr_constraints )
			memcpy(&x[nr_alg_loop], constraint_in, nr_constraints * sizeof(double));
		else
		{
			int index = 0;
			for( int i = 0; i < nr_constraints; i++ )
			{
				if( m_active_contraint_array[i] )
				{
					x[nr_alg_loop + index] = constraint_in[i];
					index++;
				}
			}
		}
	}


    if (xtol <= 0.0)
		xtol = 0.0001;

	// initialize the algebraic loop in variables on zero
	// DON'T DO THIS ANYMORE BECAUSE THE ALGEBRAIC LOOP IN VARIABLES
	// ARE NOW SEEN AS INITIAL VALUES, WHICH THE USER CAN PROVIDE.
	// THIS IS DONE IN Simulator::InitialCondsToStates()
//	for (i = 0; i < (int)n; i++)
//		algloop_in[i] = 0.0;

	ifail = 0;

    /* test if it IS necessary to determine the initial values of the algebraic-loop variables */
    /* using the root-finding function below. If the result of the initial DAE system (with     */
    /* algebraic-loop variables equal to 0) is consistent, so G(t, y, yprime) == 0, then        */
    /* calling the root-finding function is NOT needed. Dassl is capable of solving the system. */
    /* Some root-finding functions are also not capable of starting in the actual root (e.g.    */
    /* the NAG function c05nbf).   P.W.                                                         */

	// set the global_simulator variable so that the callback function knows on what model to work
	// on.
	global_simulator = m_simulator;

	if( m_check_constraints )
		global_int_method = this;

	// make sure we do NOT a major integration step
	m_simulator->m_major_step = XXFALSE;


	// set x on the initial values.

	hybrd1_(MeBDFCalcAlgloopRes, &n, x, fvec, &xtol, &ifail, wa, &lwa);

	global_int_method = NULL;
	global_simulator = NULL;


	delete[] wa;
	delete[] fvec;
	delete[] x;


	if ( ifail == 1 ) // warning : at the Netlib this was 0.
	{
		return XXTRUE;
	}

	// there was an error if we reach this point.
    switch (ifail)
	{
		case 0:
//			msg = _T("Error determining initial algebraic-loop, or constraint variables: improper input parameters for hybrid function.");
			break;
		case 2:
//			msg = _T("Error determining initial algebraic-loop, or constraint variables: very many evaluations of algebraic-loop part.");
			break;
	    case 3:
//			msg = _T("Error determining initial algebraic-loop, or constraint variables: no further improvement, tolerance too small.");
			break;
		case 4:
		case 5:
//			msg = _T("Error determining initial algebraic-loop, or constraint variables: iteration for algebraic loop is not making good progress.");
			break;
		default:
//			msg = _T("Error determining initial algebraic-loop, or constraint variables: ???");
		break;
	}
//	ShowErrorMessage(msg);

	// accept some more case, in that case let the mebdf method try
	// it for itself.
	if( ifail == 2 || ifail == 3 || ifail == 4 || ifail == 5)
		return XXTRUE;

    return XXFALSE;
}

XXBoolean MeBDFiMethod::Initialize()
{
	m_times_step_continued = 0;

	int nr_ind_states = m_simulator->GetNrIndStates();
	int nr_dep_states =  m_simulator->GetNrDepStates();
	int nr_alg_loop = m_simulator->GetNrAlgLoop();
	int nr_constraints = m_simulator->GetNrConstraints();

	// at this moment the number of active constraints are not yet determined !!!!
	int number_of_states = nr_ind_states + nr_dep_states + nr_alg_loop + nr_constraints;

	m_last_step_size = 0.0;

	// call the base class.
	if( ImplicitVariableStep::Initialize() == XXFALSE )
		return XXFALSE;

	/* check for previous attributes */
	// clear the old arrays, if there were any.
	if( m_mbnd )
		delete [] m_mbnd;
	if( m_work )
		delete [] m_work;
	if( m_iwork )
		delete [] m_iwork;
	if( m_work_states )
		delete [] m_work_states;
	if( m_work_rates )
		delete [] m_work_rates;

	if( m_prev_work )
		delete [] m_prev_work;
	if( m_prev_iwork )
		delete [] m_prev_iwork;

	if( m_active_contraint_array )
		delete [] m_active_contraint_array;

	m_nr_active_constraints = 0;

	m_prev_work = NULL;
	m_prev_iwork = NULL;
	m_active_contraint_array = NULL;

	/* check for previous attributes */
	if ( m_rtol)
		delete[] ( m_rtol);
	if ( m_atol)
		delete[] ( m_atol);

	// this should be in the initialize section
	m_local_initialStepSize = ( m_simulator->m_finishTime - m_simulator->m_startTime ) / 10000.0;// 0.0 = not appropriate
	if( m_use_initial_step_size )
		m_local_initialStepSize  = m_initial_step_size;
	m_method_flag = 22; // numerical Jacobian
	m_idid = 1; // 1 = first call, after that it is 0
	m_lout = 0; // output channel...
	m_mbnd = new int [4 + 1];
	memset(m_mbnd, 0, (4+1)*sizeof(int));
	// found in the code
/*     WORK() HOUSES THE FOLLOWING ARRAYS */
/*     Y(N,12)   , YHOLD(N,12) , YNHOLD(N,2) , YMAX(N) */
/*     ERRORS(N) , SAVE1(N) , SAVE2(N) , SCALE(N) , ARH(N) , PW(MBND(4)*N)
 */
/*     PWCOPY(MBND(4)*N) */
/*     IF THE BANDED OPTION IS NOT BEING USED THEN MBND(4)=N. */
	// so :
	m_mbnd[3] = number_of_states;


	m_maxder = 7; // the recommended value.
	m_itol = 2;// indicator of the type of error control.
				 // THE FOLLOWING TABLE GIVES THE TYPES (SCALAR/ARRAY) */
				 // OF RTOL AND ATOL, AND THE CORRESPONDING FORM OF ewt(i) */
				 //	  ITOL   RTOL      ATOL       ewt(i) */
				 //	   2    SCALAR    SCALAR   rtol*abs(y(i))   + atol */
				 //	   3    SCALAR    ARRAY    rtol*abs(y(i))   + atol(i) */
				 //	   4    ARRAY     SCALAR   rtol(i)*abs(y(i))+ atol */
				 //	   5    ARRAY     ARRAY    rtol(i)*abs(y(i))+ atol(i) */

	m_rpar = 0.0;
	m_ipar = 0;
	m_ierr = 0;

	m_lwork = 2 * ((32 + m_mbnd[3]) * number_of_states + 3) + 2;	// the length of the lwork

	m_work = new double[m_lwork + 1];
	memset(m_work, 0, (m_lwork) * sizeof(double));

	m_liwork = 2 * (number_of_states + 14) + 2;	// the length of the iwork

	m_iwork = new int[m_liwork + 1];
	memset(m_iwork, 0, (m_liwork) * sizeof(int));

	// if the first element is filled in the complete number of equations
	// given to the integration method must fulfill that m_iwork[0] + m_iwork[1] + m_iwork[2] == number_of_states
	m_iwork[0] = nr_ind_states;				 // index 1 variables = number of independent states
	m_iwork[1] = nr_dep_states + nr_alg_loop;// index 2 variables = number of dependent states and algebraic loops
	m_iwork[2] = nr_constraints;			 // index 3 variables = number of constraint variables.

	// special case if we don't have any independent states:
	// too catch the check in the integration method, there m_iwork[0] is made number_of_states
	// if m_iwork[0] == 0, without checking m_iwork[1] and m_iwork[2]
	if( nr_ind_states == 0 )
	{
		// let the method figure it out by itself.
		// this is actually always an option...
		m_iwork[0] = 0;
		m_iwork[1] = 0;
		m_iwork[2] = 0;
	}

	m_iwork[13] = 2147483647; // 500; // maximum number of allowed steps. Set every time, so always continue

	m_rtol = new double[number_of_states + 1];
	m_atol = new double[number_of_states + 1];

	if( number_of_states > 0 )
	{
		int i;
		for (i = 0; i < nr_ind_states + nr_dep_states; i++)
		{
			m_rtol[i] = m_relative_tolerance;
			m_atol[i] = m_absolute_tolerance;
		}

		// and the rest
		for ( ; i < number_of_states; i++)
		{
			m_rtol[i] = m_alg_relative_tolerance;
			m_atol[i] = m_alg_absolute_tolerance;
		}
	}

	m_work_states = new double [number_of_states + 1];
	m_work_rates = new double [number_of_states + 1];

	if( m_check_constraints )
	{
		if( nr_constraints > 0 )
			m_active_contraint_array = new XXBoolean[nr_constraints + 1];
		else
			m_active_contraint_array = NULL;
		m_nr_active_constraints = 0;
	}
	else
	{
		// to make sure we don't have a mistake somewhere.
		m_nr_active_constraints = nr_constraints;
	}

	// reinitialize from here
	ReInitialize(XXTRUE, XXTRUE);

	// now this one might have changed !!!!!
	m_iwork[2] = m_nr_active_constraints;	 // index 3 variables = number of constraint variables.
	number_of_states = nr_ind_states + nr_dep_states + nr_alg_loop + m_nr_active_constraints;
	m_lwork = 2 * ((32 + m_mbnd[3]) * number_of_states + 3) + 2;	// the length of the lwork
	m_liwork = 2 * (number_of_states + 14) + 2;	// the length of the iwork
	m_mbnd[3] = number_of_states;

	// and initialize the static state, since some variables are used before given a value
	// 'cause fortran assumes zero-initialization.
	InitializeMeBDFiState();

	return XXTRUE;
}

// this method provides a way to restart the integration method at a certain state (and time)
// without reallocating all work arrays
XXBoolean MeBDFiMethod::ReInitialize(XXBoolean major_step, XXBoolean calcModel)
{
	int nr_ind_states = m_simulator->GetNrIndStates();
	int nr_dep_states =  m_simulator->GetNrDepStates();
	int nr_alg_loop = m_simulator->GetNrAlgLoop();
	int nr_constraints = m_simulator->GetNrConstraints();

	// here the active constraints have te be determined !!!
	int number_of_states = nr_ind_states + nr_dep_states + nr_alg_loop + nr_constraints;

	if (ImplicitVariableStep::ReInitialize(major_step, calcModel) == XXFALSE)
	{
		return XXFALSE;
	}

	// this should be in the initialize section
	m_local_initialStepSize = m_simulator->m_finishTime / 1000.0;// 0.0 = not appropriate
	if( m_use_initial_step_size )
		m_local_initialStepSize  = m_initial_step_size;

	// if we are surely in an initialize state then
	// start with a first call an initial value problem
	if( m_simulator->m_reinitState || m_simulator->m_initState )
	{
		m_idid = 1; // 1 = first call, after that it is 0
	}
	else
	{
		// assume we are placed back gracefully to a previous time
		// and that a first call step is not necessary.
		// go exactly to the output
		if( m_take_desired_step_busy )
		{
			// if we're reset from the starting point, then really
			// start all over again
			if( m_simulator->m_simulationTime == m_simulator->m_startTime )
				m_idid = 1;
			else
				// now we can use some information from the past

				// this must be 0. Integration will go sligthly beyond tout
				// but will interpolate to tout to give the proper answer.
				// this is fine for event detection! To go precisely to the point
				// you will get in trouble with event localization!.
				m_idid = 0;
		}
		else
		{
			m_idid = 3;
		}
	}

	// check if we must take a used step size.
	if( number_of_states == 0 )
	{
		if( m_use_comm_int )
		{
			m_fixed_step_size = m_comm_int;
		}
		else
		{
			if( m_use_maximum_step_size )
			{
				m_fixed_step_size = m_maximum_step_size;
			}
			else
			{
				if( m_use_initial_step_size )
					m_fixed_step_size = m_initial_step_size;
				else
				{
					m_fixed_step_size = (m_simulator->m_finishTime - m_simulator->m_startTime ) / 1000;
				}
			}
		}

		// check if we have to set the fixed step size for a desired step
		if( m_take_desired_step_busy )
			m_fixed_step_size = m_simulator->m_finishTime - m_simulator->m_simulationTime;
		m_use_fixed_step_size = XXTRUE;
	}
	else
	{
		m_use_fixed_step_size = XXFALSE;

		if( m_use_comm_int )
		{
			m_fixed_step_size = m_comm_int;
		}
		else
			m_fixed_step_size = 0.0;
	}

	// calculate the static equations
//	m_simulator->CalcInit();

	if( calcModel )
	{
		m_simulator->CalcStatic();

		// and calculate the initial value problem
		m_simulator->CalcInput();

		// make sure we do a major integration step
		m_simulator->m_major_step = major_step;

		m_simulator->CalcDynamic();
	}

	// don't do the output part here yet, because the algebraic loop procedure
	// might call the dynamic block again.
	// so do the output equation at the end of this function
	if( number_of_states > 0 )
	{
		// only determine algloop of we not in a take desired step
		// in that case we assume to have been placed back gracefully
		// to a previous time will all states intact.
		if( m_simulator->m_reinitState || m_simulator->m_initState )
		{
			// if there are algebraic loop or constraint variables in the system, try to calculate the initial
			// values of those variables using hybrid.
			if ( DetermineAlgloop() == XXFALSE )
			{
				return XXFALSE;
			}
		}

		// if no algebraic loop variables return..
		// set the dependent states in the states array, to the value of the dependent states calculated
		// see for details of the specific arrays the initialization function of the simulator.
		if( nr_dep_states > 0 )
		{
			double *states = m_simulator->GetStates();
			double *dep_states = m_simulator->GetDepStates();
			memcpy(&states[nr_ind_states], dep_states,  nr_dep_states * sizeof(double));
		}

		m_tout = m_use_fixed_step_size ? m_simulator->m_simulationTime : m_simulator->m_finishTime;
	}
	else
		m_tout = m_simulator->m_simulationTime;

	if( calcModel )
	{
		// we did a dynamic block calculation, so the output must be up to date with this
		// calculation.
		m_simulator->CalcOutput();
	}

	return XXTRUE;
}

void MeBDFiMethod::Integrate()
{
	XXBoolean init_good = XXTRUE;

	int nr_ind_states = m_simulator->GetNrIndStates();
	int nr_dep_states =  m_simulator->GetNrDepStates();
	int nr_alg_loop = m_simulator->GetNrAlgLoop();
	int nr_constraints = m_simulator->GetNrConstraints();

	double *indep_states = m_simulator->GetIndepStates();
	double *dep_states = m_simulator->GetDepStates();
	double *indep_rates = m_simulator->GetIndepRates();
	double *dep_rates = m_simulator->GetDepRates();
	double *algloop_in = m_simulator->GetAlgLoopIn();
	double *algloop_out = m_simulator->GetAlgLoopOut();
	double *constraint_in = m_simulator->GetConstraintIn();

	// and the output to check
	double *constraint_out = m_simulator->GetConstraintOut();

	int number_of_states = nr_ind_states + nr_dep_states + nr_alg_loop + m_nr_active_constraints;

	if( m_use_fixed_step_size && number_of_states == 0 )
	{
		m_last_step_size = m_fixed_step_size;

		if( m_take_desired_step_busy )
		{
			m_simulator->m_simulationTime = m_simulator->m_finishTime;
		}
		else
		{
			// this is an Euler step with no states or rates.
			m_simulator->m_simulationTime += m_fixed_step_size;
		}

		/* calc the dynamic model, since the last values given by dassl are not yet gone
		through the model. */
		// make sure we do a major integration step
		m_simulator->m_major_step = XXTRUE;

		m_simulator->CalcDynamic();

		/* calculate the model to obtain all variables to be up to date */
//		m_simulator->CalcOutput();
		return;
	}

	// take a variable step using ddassl from netlib.

	/* actual call to dassl routine */
	global_simulator = m_simulator;

	if( m_check_constraints )
		global_int_method = this;

	// make sure we do NOT a major integration step
	m_simulator->m_major_step = XXFALSE;

	m_last_step_size = m_simulator->m_simulationTime;

	// this will copy all the initial values too.
	if( nr_constraints == m_nr_active_constraints )
	{
		memcpy(m_work_states, states, number_of_states * sizeof(double));
		memcpy(m_work_rates, rates, number_of_states * sizeof(double));
	}
	else
	{
		// the states
		memcpy(m_work_states, states, (nr_ind_states + nr_dep_states + nr_alg_loop) * sizeof(double));
		memcpy(m_work_rates, rates, (nr_ind_states + nr_dep_states + nr_alg_loop) * sizeof(double));

		// the constraints
		double *constraintInArray =  &m_work_states[nr_ind_states + nr_dep_states + nr_alg_loop];
		double *constraintOutArray = &m_work_rates[nr_ind_states + nr_dep_states + nr_alg_loop];
		int i, index = 0;
		for( i = 0; i < nr_constraints; i++)
		{
			if( m_active_contraint_array[i] )
			{
				constraintInArray[index] = states[nr_ind_states + nr_dep_states + nr_alg_loop + i];
				constraintOutArray[index] = rates[nr_ind_states + nr_dep_states + nr_alg_loop + i];
				index++;
			}
			else
			{
				// is this necessary ??
				states[nr_ind_states + nr_dep_states + nr_alg_loop + i] = 0.0;
			}
		}
	}

	// normally to the end of simulation is the maximum step
	double max_step;

	double rememberInitialStep = m_local_initialStepSize;
	if( m_take_desired_step_busy )
	{
		m_local_initialStepSize = (m_tout - m_simulator->m_simulationTime) / 1000.0;
	}

	if( m_use_maximum_step_size && (m_take_desired_step_busy == XXFALSE ) )
		// but maximum step can be restricted...
		max_step = m_simulator->m_simulationTime + m_maximum_step_size;
	else
		max_step = m_tout;


	mebdfi_(&number_of_states, &m_simulator->m_simulationTime, &m_local_initialStepSize ,
			m_work_states, // initial values for the states, on first call
			m_work_rates, // initial value for the rates, on first call.
			&m_tout,
			&max_step, // end of the range of integration ?????
			&m_method_flag,
			&m_idid, // the type of call, init is 1, after that zero
			&m_lout, // output channel for message passing ????

			// the work arrays
/*    THE DIMENSION OF THE REAL WORKSPACE, WORK, HAS TO BE AT LEAST */
/*     (32 + MBND(4))*N+2 WHILE THE DIMENSION OF THE INTEGER */
/*    WORKSPACE HAS TO BE AT LEAST N+14. */
			&m_lwork,
			m_work,
			&m_liwork,
			m_iwork,

			m_mbnd, // for use when the newton iteration is banded
					// not used because we specified 22 for the m_method_flag.
			&m_maxder, // the maximum order is maxdr + 1.
			&m_itol,	// the tolerance flag, probably 2 for errors being both a scalar
			m_rtol,		// the relative tolerance
			m_atol,		// the absolute tolerance
			&m_rpar,		// for communication between f and pderv and the user's calling program
			&m_ipar,		// for communication between f and pderv and the user's calling program
			NULL,		// the pderv function, is a dummy, maybe it can be NULL
			MeBDFImplicitResidu,
			&m_ierr);


	if( m_take_desired_step_busy == XXTRUE )
	{
		m_local_initialStepSize = rememberInitialStep;
	}

	// should we reset the m_idid flag to 0 explicitly for continuation after initial call?

	global_int_method = NULL;
	global_simulator = NULL;

	// remember the last step taken.
	m_last_step_size = m_simulator->m_simulationTime - m_last_step_size;

	// Set back the boolean of major steps
	m_simulator->m_major_step = XXTRUE;

	if( m_idid >= 0 )
	{
		// if it was a successful first call
		// set the m_idid flag to the continue integration step
		if( m_idid == 1 )
		{
			if( m_take_desired_step_busy )
				// go exactly to the output
				m_idid = 2;
			else
				// free to go over the output point but return after one point
				m_idid = 3;
		}

		// everything was alright
		// calc the dynamic model, since the last values given by dassl are not yet gone
		//through the model.

		if( nr_constraints == m_nr_active_constraints )
		{
			memcpy( states, m_work_states, number_of_states * sizeof(double));
			memcpy( rates, m_work_rates, number_of_states * sizeof(double));
		}
		else
		{
			// the states
			memcpy(states, m_work_states, (nr_ind_states + nr_dep_states + nr_alg_loop) * sizeof(double));
			memcpy(rates, m_work_rates, (nr_ind_states + nr_dep_states + nr_alg_loop) * sizeof(double));

			// the constraints
			double *constraintInArray =  &m_work_states[nr_ind_states + nr_dep_states + nr_alg_loop];
			double *constraintOutArray =  &m_work_rates[nr_ind_states + nr_dep_states + nr_alg_loop];
			int i, index = 0;
			for( i = 0; i < nr_constraints; i++)
			{
				if( m_active_contraint_array[i] )
				{
					states[nr_ind_states + nr_dep_states + nr_alg_loop + i] = constraintInArray[index];
					rates[nr_ind_states + nr_dep_states + nr_alg_loop + i] = constraintOutArray[index];
					index++;
				}
#if 0
				else
				{
					// is this necessary
//					rates[i] = 0;
					
					// grn: 2008-02-15, this should probably be then:
					rates[nr_ind_states + nr_dep_states + nr_alg_loop + i] = 0;
				}
#endif
			}
		}

		m_simulator->CalcDynamic();

		// and we're ready
		return;
	}

	// check if there is a possibility to continue
	if( m_idid >= -12 && ididrestart[-m_idid] >= 0)
	{
		m_times_step_continued++;
		if( m_times_step_continued >= 50 )
		{
			// and reset the thins
			m_times_step_continued = 0;
		}
//		else
//		{
//			ShowWarningMessage(_T("About 500 steps are taken: Modified BDF Method is not making good progress..."));
//		}

		if( 1 ) // answer == IDYES )
		{
			init_good = XXTRUE;
			if( ididrestart[-m_idid] == 0 )
			{
				// tell bdf to make an initial step again,
				// this will be made 1 after the initialization.
				m_idid = -1;

				// make sure we do NOT a major integration step
				m_simulator->m_major_step = XXFALSE;

				// if no algebraic loop variables return..
				// set the dependent states in the states array, to the value of the dependent states calculated
				// see for details of the specific arrays the initialization function of the simulator.
				if( nr_dep_states > 0 )
				{
					double *states = m_simulator->GetStates();
					double *dep_states = m_simulator->GetDepStates();
					memcpy(&states[nr_ind_states], dep_states,  nr_dep_states * sizeof(double));
				}

				// this will also determine the constraint variables.
				init_good = DetermineAlgloop();
			}

			if( init_good == XXTRUE )
			{
				// just try again, with a new initialization
				// calc the dynamic model, since the last values given by dassl are not yet gone
				// through the model.

				// make sure we do a major integration step
				m_simulator->m_major_step = XXTRUE;

				m_simulator->CalcDynamic();

				// and we're ready
				return;
			}
		}
	}

	// here it was all wrong, so tell the simulator to stop.
	m_simulator->m_finishrequest = XXTRUE;

	// Show some error information according to the idid value.
	if ( m_idid >= -12 )
	{

		switch( m_idid )
		{
			case -1:
/*
				errorMessage.Format(_T("Modified BDF Method: The integration was halted after failing\n\
to pass the error test even after reducing the stepsize by a\n\
factor of 1e10 from its initial value"));
*/
				break;
			case -2:
/*
				errorMessage.Format(_T("Modified BDF Method: After some initial success, the integration\n\
was halted either by repeated error test failures or by\n\
a test on (relative tolerance)/(absolute tolerance).\n\
Too much accuracy has been requested."));
*/
				break;
			case -3:
/*
				errorMessage.Format(_T("Modified BDF Method: The integration was halted after failing\n\
to achieve corrector convergence even after reducing the stepsize\n\
by a factor of 1e10 from its initial value"));
*/
				break;
			case -4:
/*
				errorMessage.Format(_T("Modified BDF Method: Immediate halt because of illegal values\n\
of input parameters."));
*/
				break;
			case -5:
/*
				// this message will not be presented to the user.
				errorMessage.Format(_T("Modified BDF Method: idid was -1 on input, but the desired changes\n\
of parameters were not implemented because tout was beyond t.\n\
Interpolation at t = tout was performed as on a normal return.\n\
To try again simply call again with idid = -1 and a new tout."));
*/
				break;
			case -6:
/*
				errorMessage.Format(_T("Modified BDF Method: Maximum allowable number of integration steps\n\
exceeded to continue."));
*/
				break;
			case -7:
/*
				errorMessage.Format(_T("Modified BDF Method: Stepsize is too small"));
*/
				break;
			case -11:
/*
				errorMessage.Format(_T("Modified BDF Method: Insufficient real workspace for the integration."));
*/
				break;
			case -12:
/*
				errorMessage.Format(_T("Modified BDF Method: Insufficient integer workspace for the integration."));
*/
				break;
			default:
/*
				errorMessage.Format(_T("Modified BDF Method: Unknown Error"));
*/
				break;
		}
/*
		char *message = new char [ errorMessage.GetLength() + 1];
		strcpy(message, errorMessage);
		ShowErrorMessage(message);
		delete[] message;
*/
	}
}

void MeBDFiMethod::InitializeMeBDFiState()
{
	memset(m_mebdfStaticInts, 0, 35 *sizeof(int));
	memset(m_mebdfStaticDoubles, 0, 26 *sizeof(double));
	memset(m_mebdfStaticLogicals, 0, 5 *sizeof(long int));
	SetMeBDFiStatics(m_mebdfStaticInts,
					m_mebdfStaticDoubles,
					m_mebdfStaticLogicals);

}
// this is to be able to reset the simulator on the previous time...
// it will remember the work arrays...
void MeBDFiMethod::RememberState()
{
	if( m_prev_work == NULL )
	{
		// allocate since it is the first call
		m_prev_work = new double[m_lwork + 1];
	}
	if( m_prev_iwork == NULL )
	{
		// allocate since it is the first call
		m_prev_iwork = new int[m_liwork + 1];
	}

	m_prev_idid = m_idid;

	// and do memcopies
	memcpy(m_prev_work, m_work, m_lwork * sizeof(double));
	memcpy(m_prev_iwork, m_iwork, m_liwork * sizeof(int));


	RememberMeBDFiStatics(m_mebdfStaticInts,
							m_mebdfStaticDoubles,
							m_mebdfStaticLogicals);

	// and the base class
	ImplicitVariableStep::RememberState();
}
void MeBDFiMethod::SetBackRememberedState()
{
	if( m_prev_work == NULL || m_prev_iwork == NULL )
		return;

	m_idid = m_prev_idid;

	// and do memcopies
	memcpy(m_work, m_prev_work, m_lwork * sizeof(double));
	memcpy(m_iwork, m_prev_iwork, m_liwork * sizeof(int));

	SetMeBDFiStatics(m_mebdfStaticInts,
					m_mebdfStaticDoubles,
					m_mebdfStaticLogicals);

	// and the base class
	ImplicitVariableStep::SetBackRememberedState();
}

// this function is used to steer the integration method when
// an event occurs. It takes the next step with a size equal to the
// supplied argument (and resets to the previous step size afterwards)
void MeBDFiMethod::TakeDesiredStep (double *u, double h)
{
	ImplicitVariableStep::TakeDesiredStep(u, h);

	// tell mebdf to start again with an initialization (since the timing has changed)
	// new by grn...
	m_idid = 1;

	return;

	int nr_ind_states = m_simulator->GetNrIndStates();
	int nr_dep_states =  m_simulator->GetNrDepStates();
	int nr_alg_loop = m_simulator->GetNrAlgLoop();
	int nr_constraints = m_simulator->GetNrConstraints();

//	int number_of_states = nr_ind_states + nr_dep_states + nr_alg_loop + nr_constraints;
	int number_of_states = nr_ind_states + nr_dep_states + nr_alg_loop + m_nr_active_constraints;

	// set the new finish time on the desired step
	// remembering the current finish time
	double previous_finish_time = m_simulator->m_finishTime;
	m_simulator->m_finishTime = m_simulator->m_simulationTime + h;

	// make sure the method knows, that it has to integrate to the
	// desired step
	m_take_desired_step_busy = XXTRUE;

	// re-initialize the method
	// with a non-major step
//    ReInitialize(XXFALSE, XXTRUE);

/*******************************************************************/
// put the integration method in a state where it goes exactly to the
// desired output time
/*******************************************************************/
	if( number_of_states == 0 )
	{
		// just use a fixed step size, to go the the desired time
		m_fixed_step_size = m_simulator->m_finishTime - m_simulator->m_simulationTime;
		m_use_fixed_step_size = XXTRUE;
	}
	// tell mebdf to start again with an initialization (since the timing has changed)
	m_idid = 1;
	m_tout = m_simulator->m_finishTime;

/*******************************************************************/
// No simulate until end-time is reached.
/*******************************************************************/
	m_simulator->m_major_step = XXTRUE;

	// simulate until the the finish time is reached
	while(m_simulator->OneSimulationStep(u, NULL));

/*******************************************************************/
// Set back the correct state, where we simulate normally again.
/*******************************************************************/
	m_take_desired_step_busy = XXFALSE;

	// and set back the finish time
	m_simulator->m_finishTime = previous_finish_time;

	// normal continuation, output each point...

	// the next time, completely reinitialize again
	m_idid = 1;

	if( number_of_states == 0 )
	{
		if( m_use_comm_int )
		{
			m_fixed_step_size = m_comm_int;
		}
		else
		{
			if( m_use_maximum_step_size )
			{
				m_fixed_step_size = m_maximum_step_size;
			}
			else
			{
				if( m_use_initial_step_size )
					m_fixed_step_size = m_initial_step_size;
				else
				{
//					if( m_simulator->GetEventOrResetOccurred() )
//						m_fixed_step_size = (m_simulator->m_finishTime - m_simulator->m_startTime ) / 1000;
//					else
						m_fixed_step_size = (m_simulator->m_finishTime - m_simulator->m_simulationTime ) / 1000;
				}
			}
		}
		m_tout = m_simulator->m_simulationTime;
	}
	else
	{
		if( m_use_comm_int )
		{
			m_fixed_step_size = m_comm_int;
		}
		else
			m_fixed_step_size = 0.0;
		m_tout = m_use_fixed_step_size ? m_simulator->m_simulationTime : m_simulator->m_finishTime;
	}
}

