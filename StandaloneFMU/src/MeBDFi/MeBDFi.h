/**********************************************************
 * This file is generated by the 20-sim C++ Code Generator
 *
 *  file:  %FILE_NAME%
 *  subm:  %SUBMODEL_NAME%
 *  model: %MODEL_NAME%
 *  expmt: %EXPERIMENT_NAME%
 *  date:  %GENERATION_DATE%
 *  time:  %GENERATION_TIME%
 *  user:  %USER_NAME%
 *  from:  %COMPANY_NAME%
 *  build: %GENERATION_BUILD%
 **********************************************************/

#ifndef __MEBDFI_H
#define __MEBDFI_H

typedef struct IntegrationMethod
{
	XXBoolean m_take_desired_step_busy;
	struct %VARPREFIX%ModelInstance* m_model_instance;
} IntegrationMethod;
typedef struct ImplicitMethod
{
	IntegrationMethod m_integration_method;

	double m_absolute_tolerance;
	double m_relative_tolerance;

	double m_alg_absolute_tolerance;
	double m_alg_relative_tolerance;
} ImplicitMethod;
typedef struct ImplicitVariableStep
{
	/* inheritance replaced by membership */
	ImplicitMethod m_implicit_method;

	XXBoolean m_use_initial_step_size;
	XXBoolean m_use_maximum_step_size;
	double m_initial_step_size;
	double m_maximum_step_size;
	double m_last_step_size;
	
	/* for remembering the internal state */
	double m_prev_last_step_size;
} ImplicitVariableStep;

/***********************************************************
 * Modified Backward Differentiation Formula
 * for problems of the form
 * G(T,Y,Y')=0.
 ***********************************************************/
typedef struct MeBDFiMethod
{
	/* inheritance replaced by membership */
	ImplicitVariableStep m_implicit_variable_step;

	/* member variables for MeBDFi itself */
	double m_tout;
	double m_local_initialStepSize;
	int m_method_flag;
	int m_idid;
	int m_lout;
	int *m_mbnd;
	int m_maxder;
	int m_itol;
	double *m_rtol;
	double *m_atol;
	double m_rpar;
	int m_ipar;
	int m_ierr;
	int m_lwork;
	double *m_work;
	int m_liwork;
	int *m_iwork;

	double *m_Y;
	double *m_YPRIME;

	// and new work arrays to make the bdf method re-entrant */
	int m_mebdfStaticInts[35]; // 34 + 1
	double m_mebdfStaticDoubles[26]; // 25 + 1
	long int m_mebdfStaticLogicals[5]; // 4 + 1

	/* and some values, to be able to reset the method
	 * to a previous time (in event detection) */
	double *m_prev_work;
	int *m_prev_iwork;
	int m_prev_idid;

	int m_times_step_continued;

	XXBoolean m_use_fixed_step_size;
	double m_fixed_step_size;

	// boolean to determine whether a communication interval should be used
	XXBoolean m_use_comm_int;

	// if the boolean is true is this communication interval
	double m_comm_int;

	/* this will trigger that additional
	 * state and rate arrays are used (with copy action at
	 * the beginning and end of each simulation step), but
	 * that this new array can be of variable length. We will
	 * numerically check if a constraint should be active or not
	 * sometimes a constraint is not controllable, but then it appears
	 * that there is no need to control this... (because of the structure
	 * of the system it is implicitily constraint).
	 */
	XXBoolean m_check_constraints;
	XXBoolean *m_active_contraint_array;
	int m_nr_active_constraints;
} MeBDFiMethod;

/*
 * function to determine the initial values for the algebraic
 * loop variables
 */
XXBoolean MeBDFiMethod_DetermineAlgloop(MeBDFiMethod *mebdfi_method);

/* should "smart" constraints be used */
XXBoolean MeBDFiMethod_GetUseSmartConstraints(MeBDFiMethod *mebdfi_method);
XXBoolean MeBDFiMethod_SetUseSmartConstraints(MeBDFiMethod *mebdfi_method, XXBoolean set);

/* determine the active constraints */
void MeBDFiMethod_DetermineActiveConstraints(MeBDFiMethod *mebdfi_method);
XXBoolean MeBDFiMethod_CheckNonActiveConstraints(MeBDFiMethod *mebdfi_method);

/* the constructor for the MeBDFi object */
void IntegrationMethod_Constructor(IntegrationMethod *intMethod, struct %VARPREFIX%ModelInstance* model_instance);
void ImplicitMethod_Constructor(ImplicitMethod *implMethod, struct %VARPREFIX%ModelInstance* model_instance);
void ImplicitVariableStep_Constructor(ImplicitVariableStep *implVarStepMethod, struct %VARPREFIX%ModelInstance* model_instance);
void MeBDFiMethod_Constructor (MeBDFiMethod *meBDFi, struct %VARPREFIX%ModelInstance* model_instance);

/* initialize functions */
XXBoolean MeBDFiMethod_Initialize(MeBDFiMethod *mebdfi_method);
XXBoolean MeBDFiMethod_ReInitialize(MeBDFiMethod *mebdfi_method, XXBoolean major_step, XXBoolean calcModel);

/* 
 * do an integration step with the current settings
 * assume that the object has been initialized so that
 * no speed is lost in checking this.
 */
void MeBDFiMethod_Integrate(MeBDFiMethod *meBDFi, double outputTime, double finishTime);

XXBoolean MeBDFiMethod_GetUseCommunicationInterval(MeBDFiMethod *mebdfi_method);
void MeBDFiMethod_UseCommunicationInterval(MeBDFiMethod *mebdfi_method, XXBoolean use_it);
double MeBDFiMethod_GetCommunicationInterval(MeBDFiMethod *mebdfi_method);
void MeBDFiMethod_SetCommunicationInterval(MeBDFiMethod *mebdfi_method, double comm_int);

/*
 * this is to be able to reset the simulator on the previous time...
 * it will remember the work arrays...
 */
void MeBDFiMethod_InitializeMeBDFiState(MeBDFiMethod *mebdfi_method);
void MeBDFiMethod_RememberState(MeBDFiMethod *mebdfi_method);
void MeBDFiMethod_SetBackRememberedState(MeBDFiMethod *mebdfi_method);

void MeBDFiMethod_TakeDesiredStep (MeBDFiMethod *mebdfi_method, double *u, double h);

/* this method can handle the algebraic relations itself. */
XXBoolean MeBDFiMethod_CanHandleAlgebraicRelations(MeBDFiMethod *mebdfi_method);
XXBoolean MeBDFiMethod_CanHandleConstraints(MeBDFiMethod *mebdfi_method);

void MeBDFiMethod_Destructor(MeBDFiMethod *mebdfi_method);

#endif

