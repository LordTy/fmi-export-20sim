/**********************************************************
 * This file is generated by 20-sim ANSI-C Code Generator
 *
 *  file:  %FILE_NAME%
 *  subm:  %SUBMODEL_NAME%
 *  model: %MODEL_NAME%
 *  expmt: %EXPERIMENT_NAME%
 *  date:  %GENERATION_DATE%
 *  time:  %GENERATION_TIME%
 *  user:  %USER_NAME%
 *  from:  %COMPANY_NAME%
 *  build: %GENERATION_BUILD%
 **********************************************************/

/* This file describes the integration methods
   that are supplied for computation.

   Currently only Euler, RungeKutta2 and RungeKutta4 are supplied,
   but it is easy for the user to add their own
   integration methods with these two as an example.
*/

/* the system include files */
#include <stdlib.h>
#include <string.h>
#include <math.h>

/* our own include files */
#include "xxinteg.h"
#include "xxmodel.h"

/* global variables prototypes */
extern XXDouble %VARPREFIX%%XX_TIME%;
extern XXDouble %VARPREFIX%step_size;

%IF%%NUMBER_STATES%
#define %VARPREFIX%STATE_SIZE %NUMBER_STATES%
%ENDIF%

#ifdef Discrete_METHOD
/*********************************************************************
 * Discrete integration method
 *********************************************************************/

/* the initialization of the Discrete integration method */
void %FUNCTIONPREFIX%DiscreteInitialize (void)
{
	/* nothing to be done */
	%VARPREFIX%major = XXTRUE;
}

/* the termination of the Discrete integration method */
void %FUNCTIONPREFIX%DiscreteTerminate (void)
{
	/* nothing to be done */
}

/* the Discrete integration method itself */
void %FUNCTIONPREFIX%DiscreteStep (void)
{
%IF%%NUMBER_STATES%
	XXInteger index;

	/* for each of the supplied states */
	for (index = 0; index < %VARPREFIX%STATE_SIZE; index++)
	{
		/* just a move of the new state */
		%VARPREFIX%%XX_STATE_ARRAY_NAME% [index] = %VARPREFIX%%XX_RATE_ARRAY_NAME% [index];
	}
%ELSE%
	/* no states in the model */
%ENDIF%
	/* increment the simulation time */
	%VARPREFIX%%XX_TIME% += %VARPREFIX%step_size;

	%VARPREFIX%major = XXTRUE;

	/* evaluate the dynamic part to calculate the new rates */
	%FUNCTIONPREFIX%CalculateDynamic ();
}
#endif /* Discrete_METHOD */


#ifdef Euler_METHOD
/*********************************************************************
 * Euler integration method
 *********************************************************************/

/* the initialization of the Euler integration method */
void %FUNCTIONPREFIX%EulerInitialize (void)
{
	/* nothing to be done */
	%VARPREFIX%major = XXTRUE;
}

/* the termination of the Euler integration method */
void %FUNCTIONPREFIX%EulerTerminate (void)
{
	/* nothing to be done */
}

/* the Euler integration method itself */
void %FUNCTIONPREFIX%EulerStep (void)
{
%IF%%NUMBER_STATES%
	XXInteger index;

	/* for each of the supplied states */
	for (index = 0; index < %VARPREFIX%STATE_SIZE; index++)
	{
		/* calculate the new state */
		%VARPREFIX%%XX_STATE_ARRAY_NAME% [index] = %VARPREFIX%%XX_STATE_ARRAY_NAME% [index] + %VARPREFIX%%XX_RATE_ARRAY_NAME% [index] * %VARPREFIX%step_size;
	}
%ELSE%
	/* no states in the model */
%ENDIF%
	/* increment the simulation time */
	%VARPREFIX%%XX_TIME% += %VARPREFIX%step_size;

	%VARPREFIX%major = XXTRUE;

	/* evaluate the dynamic part to calculate the new rates */
	%FUNCTIONPREFIX%CalculateDynamic ();
}
#endif /* Euler_METHOD */


#ifdef RungeKutta2_METHOD
/*********************************************************************
 * RungeKutta2 integration method
 *********************************************************************/
%IF%%NUMBER_STATES%
/* static variables for the selected integration method */
static XXDouble %VARPREFIX%q0 [%VARPREFIX%STATE_SIZE];
%ENDIF%

/* the initialization of the RungeKutta2 integration method */
void %FUNCTIONPREFIX%RungeKutta2Initialize (void)
{
%IF%%NUMBER_STATES%
	/* empty our static arrays */
	memset (%VARPREFIX%q0, 0, %VARPREFIX%STATE_SIZE * sizeof (XXDouble));
%ENDIF%
}

/* the termination of the RungeKutta2 integration method */
void %FUNCTIONPREFIX%RungeKutta2Terminate (void)
{
	/* nothing yet (our arrays are static) */
}


/* the Runge-Kutta-2 integration method itself */
void %FUNCTIONPREFIX%RungeKutta2Step (void)
{
%IF%%NUMBER_STATES%
	XXInteger index;
	XXDouble rktime;

	/* This model has %NUMBER_STATES% states */
	/*********************************************************************************/
	/*          calculate intermediate result                                        */
	/*********************************************************************************/

	/* cache the simulation time */
	rktime = %VARPREFIX%%XX_TIME%;

	/* the q0 will hold the value of the last evaluation. This is used multiple times
	   so remember the complete state array in this vector. */
	memcpy (%VARPREFIX%q0, %VARPREFIX%%XX_STATE_ARRAY_NAME%, %VARPREFIX%STATE_SIZE * sizeof (XXDouble));

	/* calculate f (states, t) * 1/2 * dt  =  rates * 1/2 * dt  */
	for (index = 0; index < %VARPREFIX%STATE_SIZE; index++)
	{
		/* set the new states to use */
		%VARPREFIX%%XX_STATE_ARRAY_NAME% [index] = %VARPREFIX%q0 [index] + %VARPREFIX%%XX_RATE_ARRAY_NAME% [index] * 0.5 * %VARPREFIX%step_size;
	}

	%VARPREFIX%%XX_TIME% = rktime + 0.5 * %VARPREFIX%step_size;
	%VARPREFIX%major = XXFALSE;
	%FUNCTIONPREFIX%CalculateDynamic ();

	/* for each state */
	for (index = 0; index < %VARPREFIX%STATE_SIZE; index++)
	{
		/*********************************************************************************/
		/*          calculate the next state from the intermediate results               */
		/*********************************************************************************/

		/* calculate the next state = classical Runge-Kutta integration step */
		%VARPREFIX%%XX_STATE_ARRAY_NAME% [index] = %VARPREFIX%q0 [index] +	%VARPREFIX%%XX_RATE_ARRAY_NAME% [index] * %VARPREFIX%step_size;
	}
	%VARPREFIX%%XX_TIME% = rktime + %VARPREFIX%step_size;

%ELSE%
	/* no states in the model */
	/* increment the simulation time */
	%VARPREFIX%%XX_TIME% += %VARPREFIX%step_size;

%ENDIF%
	%VARPREFIX%major = XXTRUE;

	/* evaluate the derivative model to calculate the new rates */
	%FUNCTIONPREFIX%CalculateDynamic ();
}
#endif /* RungeKutta2_METHOD */


#ifdef RungeKutta4_METHOD
/*********************************************************************
 * RungeKutta4 integration method
 *********************************************************************/
%IF%%NUMBER_STATES%
/* static variables for the selected integration method */
static XXDouble %VARPREFIX%q0 [%VARPREFIX%STATE_SIZE];
static XXDouble %VARPREFIX%q1 [%VARPREFIX%STATE_SIZE];
static XXDouble %VARPREFIX%q2 [%VARPREFIX%STATE_SIZE];
static XXDouble %VARPREFIX%q3 [%VARPREFIX%STATE_SIZE];
static XXDouble %VARPREFIX%q4 [%VARPREFIX%STATE_SIZE];
%ENDIF%

/*********************************************************************
 * the initialization of the RungeKutta4 integration method
 */
static const XXDouble OneOverSix = 1.0 / 6.0;

void %FUNCTIONPREFIX%RungeKutta4Initialize (void)
{
%IF%%NUMBER_STATES%
	/* empty our static arrays */
	memset (%VARPREFIX%q0, 0, %VARPREFIX%STATE_SIZE * sizeof (XXDouble));
	memset (%VARPREFIX%q1, 0, %VARPREFIX%STATE_SIZE * sizeof (XXDouble));
	memset (%VARPREFIX%q2, 0, %VARPREFIX%STATE_SIZE * sizeof (XXDouble));
	memset (%VARPREFIX%q3, 0, %VARPREFIX%STATE_SIZE * sizeof (XXDouble));
	memset (%VARPREFIX%q4, 0, %VARPREFIX%STATE_SIZE * sizeof (XXDouble));
%ENDIF%
}

/* the termination of the RungeKutta4 integration method */
void %FUNCTIONPREFIX%RungeKutta4Terminate (void)
{
	/* nothing yet (our arrays are static) */
}


/* the Runge-Kutta-4 integration method itself */
void %FUNCTIONPREFIX%RungeKutta4Step (void)
{
%IF%%NUMBER_STATES%
	XXInteger index;
	XXDouble rktime;

	/* This model has %NUMBER_STATES% states */
	/*********************************************************************************/
	/*          calculate intermediate state results q1, q2, q3 and q4               */
	/*********************************************************************************/

	/* cache the simulation time */
	rktime = %VARPREFIX%%XX_TIME%;

	/* the q0 will hold the value of the last evaluation. This is used multiple times
	   so remember the complete state array in this vector. */
	memcpy (%VARPREFIX%q0, %VARPREFIX%%XX_STATE_ARRAY_NAME%, %VARPREFIX%STATE_SIZE * sizeof (XXDouble));

	/* calculate q1 = f (states, t) * dt  =  rates * dt  */
	for (index = 0; index < %VARPREFIX%STATE_SIZE; index++)
	{
		/* set the intermediate q1 */
		%VARPREFIX%q1 [index] = %VARPREFIX%%XX_RATE_ARRAY_NAME% [index] * %VARPREFIX%step_size;

		/* set the new states to use  for q2 */
		%VARPREFIX%%XX_STATE_ARRAY_NAME% [index] = %VARPREFIX%q0 [index] + %VARPREFIX%q1 [index] / 2;
	}

	/* calculate q2 = f (states + q1 / 2, t + dt / 2) * dt  */
	%VARPREFIX%%XX_TIME% = rktime + %VARPREFIX%step_size / 2;

	%VARPREFIX%major = XXFALSE;

	%FUNCTIONPREFIX%CalculateDynamic ();
	memcpy (%VARPREFIX%q2, %VARPREFIX%%XX_RATE_ARRAY_NAME%, %VARPREFIX%STATE_SIZE * sizeof (XXDouble));

	/* for each state */
	for (index = 0; index < %VARPREFIX%STATE_SIZE; index++)
	{
		/* set the ultimate q2 */
		%VARPREFIX%q2 [index] = %VARPREFIX%q2 [index] * %VARPREFIX%step_size;

		/* set the new states to use */
		%VARPREFIX%%XX_STATE_ARRAY_NAME% [index] = %VARPREFIX%q0 [index] + %VARPREFIX%q2 [index] / 2;
	}

	/* calculate q3 = f (states + q2 / 2, t + dt / 2) * dt  */
	%FUNCTIONPREFIX%CalculateDynamic ();
	memcpy (%VARPREFIX%q3, %VARPREFIX%%XX_RATE_ARRAY_NAME%, %VARPREFIX%STATE_SIZE * sizeof (XXDouble));

	/* for each state */
	for (index = 0; index < %VARPREFIX%STATE_SIZE; index++)
	{
		/* set the ultimate q3 */
		%VARPREFIX%q3 [index] = %VARPREFIX%q3 [index] * %VARPREFIX%step_size;

		/* set the new states */
		%VARPREFIX%%XX_STATE_ARRAY_NAME% [index] = %VARPREFIX%q0 [index] + %VARPREFIX%q3 [index];
	}

	/* calculate q4 = f (states + q3, t + dt) * dt */
	%VARPREFIX%%XX_TIME% = rktime + %VARPREFIX%step_size;
	%FUNCTIONPREFIX%CalculateDynamic ();
	memcpy (%VARPREFIX%q4, %VARPREFIX%%XX_RATE_ARRAY_NAME%, %VARPREFIX%STATE_SIZE * sizeof (XXDouble));

	/* for each state */
	for (index = 0; index < %VARPREFIX%STATE_SIZE; index++)
	{
		/* set the ultimate q4 */
		%VARPREFIX%q4 [index] = %VARPREFIX%q4 [index] * %VARPREFIX%step_size;

		/*********************************************************************************/
		/*          calculate the next state from the intermediate results               */
		/*********************************************************************************/

		/* calculate the next state = classical Runge-Kutta integration step */
		%VARPREFIX%%XX_STATE_ARRAY_NAME%[index] = %VARPREFIX%q0[index] + (%VARPREFIX%q1[index] + %VARPREFIX%q2[index] + %VARPREFIX%q2[index] + %VARPREFIX%q3[index] + %VARPREFIX%q3[index] + %VARPREFIX%q4[index]) * OneOverSix;
	}
%ELSE%
	/* no states in the model */
	/* increment the simulation time */
	%VARPREFIX%%XX_TIME% += %VARPREFIX%step_size;
%ENDIF%

	%VARPREFIX%major = XXTRUE;

	/* evaluate the derivative model to calculate the new rates */
	%FUNCTIONPREFIX%CalculateDynamic ();
}
#endif /* RungeKutta4_METHOD */
