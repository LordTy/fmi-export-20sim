/**********************************************************
 * This file is generated by 20-sim ANSI-C Code Generator
 *
 *  file:  %FILE_NAME%
 *  model: %MODEL_NAME%
 *  expmt: %EXPERIMENT_NAME%
 *  date:  %GENERATION_DATE%
 *  time:  %GENERATION_TIME%
 *  user:  %USER_NAME%
 *  from:  %COMPANY_NAME%
 *  build: %GENERATION_BUILD%
 **********************************************************/

/* This file contains the actual model variables and equations */

/* Note: Alias variables are the result of full optimization
   of the model in 20-sim. As a result, only the real variables
   are used in the model for speed. The user may also include
   the alias variables by adding them to the end of the array:

   XXDouble %VARPREFIX%variables[NUMBER_VARIABLES + NUMBER_ALIAS_VARIABLES + 1];
   XXCharacter *%VARPREFIX%variable_names[] = {
     VARIABLE_NAMES, ALIAS_VARIABLE_NAMES, NULL
   };

   and calculate them directly after the output equations:

   void %FUNCTIONPREFIX%CalculateOutput (void)
   {
     OUTPUT_EQUATIONS
     ALIAS_EQUATIONS
   }
*/

/* system include files */
#include <stdlib.h>
#include <math.h>

/* 20-sim include files */
#include "xxmodel.h"
#include "xxfuncs.h"
%IF%%NUMBER_MATRICES%
#include "xxmatrix.h"
%ENDIF%
%IF%%NUMBEROF_DLL_MotionProfiles%
#include "motionprofiles.h"
%ENDIF%
%IF%%NUMBEROF_DLL_EulerAngles%
#include "EulerAngles.h"
%ENDIF%
%IF%%NUMBEROF_DELAYFUNCTION%
#include <string.h> /* memcpy */
%ENDIF%
%IF%%NUMBEROF_DLL_Table2D%
#include "Table2D.h"
%ENDIF%

/* the global variables */
XXDouble %VARPREFIX%start_time = %START_TIME%;
XXDouble %VARPREFIX%finish_time = %FINISH_TIME%;
XXDouble %VARPREFIX%step_size = %TIME_STEP_SIZE%;
XXDouble %VARPREFIX%%XX_TIME% = 0.0;
XXInteger %VARPREFIX%steps = 0;
XXBoolean %VARPREFIX%%XX_INITIALIZE% = XXTRUE;
XXBoolean %VARPREFIX%major = XXTRUE;
XXBoolean %VARPREFIX%stop_simulation = XXFALSE;

/* the variable arrays */
XXDouble %VARPREFIX%MEMORY[%NUMBER_CONSTANTS% + %NUMBER_PARAMETERS% + %NUMBER_INITIAL_VALUES% + %NUMBER_VARIABLES% + %NUMBER_STATES% + %NUMBER_STATES% + 1];
XXDouble* %VARPREFIX%%XX_CONSTANT_ARRAY_NAME% = %VARPREFIX%MEMORY;		/* constants */
XXDouble* %VARPREFIX%%XX_PARAMETER_ARRAY_NAME% = %VARPREFIX%MEMORY + %NUMBER_CONSTANTS%;			/* parameters */
XXDouble* %VARPREFIX%%XX_INITIAL_VALUE_ARRAY_NAME% = %VARPREFIX%MEMORY + %NUMBER_CONSTANTS% + %NUMBER_PARAMETERS%;		/* initial values */
XXDouble* %VARPREFIX%%XX_VARIABLE_ARRAY_NAME% = %VARPREFIX%MEMORY + %NUMBER_CONSTANTS% + %NUMBER_PARAMETERS% + %NUMBER_INITIAL_VALUES%;		/* variables */
XXDouble* %VARPREFIX%%XX_STATE_ARRAY_NAME% = %VARPREFIX%MEMORY + %NUMBER_CONSTANTS% + %NUMBER_PARAMETERS% + %NUMBER_INITIAL_VALUES% + %NUMBER_VARIABLES%;		/* states */
XXDouble *%VARPREFIX%%XX_RATE_ARRAY_NAME% = %VARPREFIX%MEMORY + %NUMBER_CONSTANTS% + %NUMBER_PARAMETERS% + %NUMBER_INITIAL_VALUES% + %NUMBER_VARIABLES% + %NUMBER_STATES%;		/* rates (or new states) */
%IF%%NUMBER_MATRICES%
XXMatrix %VARPREFIX%%XX_MATRIX_ARRAY_NAME%[%NUMBER_MATRICES%];		/* matrices */
%ENDIF%
%IF%%NUMBER_UNNAMED%
XXDouble %VARPREFIX%%XX_UNNAMED_ARRAY_NAME%[%NUMBER_UNNAMED%];		/* unnamed */
%ENDIF%
%IF%%WORK_ARRAY_SIZE%
XXDouble %VARPREFIX%workarray[%WORK_ARRAY_SIZE%];
%ENDIF%
%IF%%NUMBER_FAVORITE_PARAMETERS%
XXDouble %VARPREFIX%%XX_FAVORITE_PARS_ARRAY_NAME%[%NUMBER_FAVORITE_PARAMETERS%];	/* favorite parameters */
%ENDIF%
%IF%%NUMBER_FAVORITE_VARIABLES%
XXDouble %VARPREFIX%%XX_FAVORITE_VARS_ARRAY_NAME%[%NUMBER_FAVORITE_VARIABLES%];		/* favorite variables */
%ENDIF%
%IF%%NUMBER_IMPORTS%
XXDouble %VARPREFIX%%XX_EXT_IN_ARRAY_NAME%[%NUMBER_IMPORTS%]; /* import variables */
%ENDIF%
%IF%%NUMBER_EXPORTS%
XXDouble %VARPREFIX%%XX_EXT_OUT_ARRAY_NAME%[%NUMBER_EXPORTS%]; /* export variables */
%ENDIF%
%IF%%NUMBEROF_INITIALFUNCTION%
XXDouble %VARPREFIX%initial_value_array[%NUMBEROF_INITIALFUNCTION%];	/* initial*/
%ENDIF%
%IF%%NUMBEROF_DELAYFUNCTION%
XXDouble %VARPREFIX%delay_update_array[%NUMBEROF_DELAYFUNCTION%];
XXDouble %VARPREFIX%delay_last_values[%NUMBEROF_DELAYFUNCTION%];
%ENDIF%

/* the names of the variables as used in the arrays above
   uncomment this part if these names are needed
%IF%%NUMBER_CONSTANTS%
XXCharacter *%VARPREFIX%constant_names[] = {
%CONSTANT_NAMES%,	NULL
};
%ENDIF%
%IF%%NUMBER_PARAMETERS%
XXCharacter *%VARPREFIX%parameter_names[] = {
%PARAMETER_NAMES%,	NULL
};
%ENDIF%
%IF%%NUMBER_INITIAL_VALUES%
XXCharacter *%VARPREFIX%initial_value_names[] = {
%INITIAL_VALUE_NAMES%,	NULL
};
%ENDIF%
%IF%%NUMBER_VARIABLES%
XXCharacter *%VARPREFIX%variable_names[] = {
%VARIABLE_NAMES%,	NULL
};
%ENDIF%
%IF%%NUMBER_STATES%
XXCharacter *%VARPREFIX%state_names[] = {
%STATE_NAMES%,	NULL
};
XXCharacter *%VARPREFIX%rate_names[] = {
%RATE_NAMES%,	NULL
};
%ENDIF%
%IF%%NUMBER_MATRICES%
XXCharacter *%VARPREFIX%matrix_names[] = {
%MATRIX_NAMES%,	NULL
};
%ENDIF%
%IF%%NUMBER_FAVORITE_PARAMETERS%
XXString %VARPREFIX%favorite_par_names[] = {
%FAVORITE_PARAMETER_NAMES%, NULL
};
%ENDIF%
%IF%%NUMBER_FAVORITE_VARIABLES%
XXString %VARPREFIX%favorite_var_names[] = {
%FAVORITE_VARIABLE_NAMES%, NULL
};
%ENDIF%
%IF%%NUMBER_IMPORTS%
XXString %VARPREFIX%import_names[] = {
%IMPORT_NAMES%, NULL
};
%ENDIF%
%IF%%NUMBER_EXPORTS%
XXString %VARPREFIX%export_names[] = {
%EXPORT_NAMES%, NULL
};
%ENDIF%
*/

#if (%NUMBER_PARAMETERS% > 8192) && defined _MSC_VER
#pragma optimize("", off)
#endif

/* this method is called before calculation is possible */
void %FUNCTIONPREFIX%ModelInitialize (void)
{
%IF%%NUMBER_CONSTANTS%
	/* set the constants */
%INITIALIZE_CONSTANTS%

%ENDIF%
%IF%%NUMBER_PARAMETERS%
	/* set the parameters */
%INITIALIZE_PARAMETERS%

%ENDIF%
%IF%%NUMBER_INITIAL_VALUES%
	/* set the initial values */
%INITIALIZE_INITIAL_VALUES%

%ENDIF%
%IF%%NUMBER_STATES%
	/* set the states */
%INITIALIZE_STATES%

%ENDIF%
%IF%%NUMBER_MATRICES%
	/* set the matrices */
%INITIALIZE_MATRICES%

%ENDIF%
%IF%%OR(NUMBER_FAVORITE_PARAMETERS,NUMBER_FAVORITE_VARIABLES)%
	/* set the favorites */
%INITIALIZE_FAVORITE_PARS%
%INITIALIZE_FAVORITE_VARS%
%ENDIF%
}
#if (%NUMBER_PARAMETERS% > 8192) && defined _MSC_VER
#pragma optimize("", on)
#endif

/* This function calculates the initial equations of the model.
 * These equations are calculated before anything else
 */
void %FUNCTIONPREFIX%CalculateInitial (void)
{
%IF%%NUMBER_FAVORITE_PARAMETERS%
	/* the favorite parameters equations */
%FAVORITE_PARS_EQUATIONS%
%ENDIF%

%INITIAL_EQUATIONS%
}

/* This function calculates the static equations of the model.
 * These equations are only dependent from parameters and constants
 */
void %FUNCTIONPREFIX%CalculateStatic (void)
{
%STATIC_EQUATIONS%
}

/* This function calculates the input equations of the model.
 * These equations are dynamic equations that must not change
 * in calls from the integration method (like random and delay).
 */
void %FUNCTIONPREFIX%CalculateInput (void)
{
%IF%%NUMBER_FAVORITE_PARAMETERS%
	/* the favorite parameters equations */
%FAVORITE_PARS_EQUATIONS%

%ENDIF%
%INPUT_EQUATIONS%
}

/* This function calculates the dynamic equations of the model.
 * These equations are called from the integration method
 * to calculate the new model rates (that are then integrated).
 */
void %FUNCTIONPREFIX%CalculateDynamic (void)
{
%DYNAMIC_EQUATIONS%

	/* increment the step counter */
	%VARPREFIX%steps++;
}

/* This function calculates the output equations of the model.
 * These equations are not needed for calculation of the rates
 * and are kept separate to make the dynamic set of equations smaller.
 * These dynamic equations are called often more than one time for each
 * integration step that is taken. This makes model computation much faster.
 */
void %FUNCTIONPREFIX%CalculateOutput (void)
{
%OUTPUT_EQUATIONS%
%IF%%NUMBEROF_DELAYFUNCTION%
	/* delay update */
	%FUNCTIONPREFIX%DelayUpdate();

%ENDIF%
%IF%%NUMBER_FAVORITE_VARIABLES%
	/* set the favorite variables */
%FAVORITE_VARS_EQUATIONS%
%ENDIF%
}

/* This function calculates the final equations of the model.
 * These equations are calculated after all the calculations
 * are performed
 */
void %FUNCTIONPREFIX%CalculateFinal (void)
{
%FINAL_EQUATIONS%
}

/* this method is called after all calculations are performed */
void %FUNCTIONPREFIX%ModelTerminate(void)
{
}

%IF%%NUMBEROF_DELAYFUNCTION%
void %FUNCTIONPREFIX%DelayUpdate()
{
	memcpy(%VARPREFIX%delay_update_array, %VARPREFIX%delay_last_values, %NUMBEROF_DELAYFUNCTION% * sizeof(XXDouble));
}

%ENDIF%
